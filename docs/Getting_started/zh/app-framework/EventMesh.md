# EventMesh 



`获取地址`: [源代码](https://github.com/QuecPython/EventMesh)



EventMesh是一个轻量级的事件驱动框架，主要用于在微控制器等资源受限的环境中构建高效的消息传递和事件处理系统。它允许应用程序在运行时订阅和发布事件，并且可以异步或同步地处理它们。



## 1. API使用说明



### 1.1 导入模块

使用EventMesh模块之前，需要将该模块安装到MicroPython设备中。可以将EventMesh.py文件上传到MicroPython设备中，并通过`import`命令导入该模块：

```python
from usr import EventMesh
```





### 1.2 `EventMesh.subscribe(event, cb)`

订阅一个事件。此函数接受两个参数：事件名称以及对应的回调函数。每个事件只能对应一个回调函数。

**参数：**

- `event`：事件名称，字符串类型。
- `cb`：回调函数，当事件被触发时，此函数将会被调用。

**示例：**

```python
def my_callback(event, msg):
    print(f'Event: {event}, Message: {msg}')

EventMesh.subscribe('my_event', my_callback)
```



### 1.3 `EventMesh.publish(event, msg=None)`

发布一个事件。此函数接受两个参数：事件名称以及可选的消息。此函数将同步调用事件对应的回调函数。

**参数：**

- `event`：事件名称，字符串类型。
- `msg`：可选的消息，任意类型。

**示例：**

```python
EventMesh.publish('my_event', 'Hello, World!')
```



### 1.4 `publish_async(event, msg=None)`

异步发布一个事件。此函数接受两个参数：事件名称以及可选的消息。此函数将在新的线程中调用事件对应的回调函数。

**参数：**

- `event`：事件名称，字符串类型。
- `msg`：可选的消息，任意类型。

**示例：**

```python
EventMesh.publish_async('my_event', 'Hello, World!')
```



### 1.5 `set_log(log_adapter)`

设置日志记录器。此函数接受一个参数：日志记录器对象。

**参数：**

- `log_adapter`：日志记录器对象。

**示例：**

```python
import log
my_logger = log.getLogger("T1")
EventMesh.set_log(my_logger)
```



### 1.6 `add_filter(flt)`

添加一个过滤器。此函数接受一个参数：过滤器对象。过滤器可以用于过滤出不需要记录的事件日志。

**参数：**

- `flt`：过滤器对象。

**示例：**

```python
add_filter("my_event")
```



## 2. 架构原理

EventMesh是一个基于事件驱动的轻量级消息框架，它采用了发布-订阅模式，将事件发布者和订阅者解耦，使系统更具灵活性和可扩展性。

不同于传统的消息框架，EventMesh的特点在于，每个事件（topic）只对应一个订阅函数，即一对一的模型。这样可以避免事件处理的复杂性和不确定性，提升系统的稳定性。

架构图如下：

```lua
    +-------------+                   +-------------+                  +-------------+
    |  Publisher  | -- publish -->    |  EventStore | -- notify -->    |  Subscriber |
    +-------------+                   +-------------+                  +-------------+

```

对比原先未解耦的情况的架构图：

```lua
    +-------------+                   +-------------+
    |  Publisher  | -- direct call -->|  Subscriber |
    +-------------+                   +-------------+

```

在未解耦的情况下，发布者直接调用订阅者的方法，这种方式会导致系统的组件高度耦合，一旦某个组件需要更改，可能会影响到其他的组件。而在EventMesh中，发布者只需要发布事件，不需要关心谁会处理这个事件，这样就降低了系统各组件之间的耦合度。



## 3. 优缺点

### 优点：

1. **解耦**：发布者和订阅者完全解耦，互不依赖，只需要关注自己的业务逻辑。
2. **异步处理**：支持异步事件处理，能够提高程序的性能和响应速度。
3. **一对一模型**：每个事件只有一个订阅者，避免了处理函数的冲突和竞态条件。

### 缺点：

1. **缺乏事件监控**：由于事件的处理是异步的，因此很难对事件的处理进行监控和调试。(默认是非异步模式除非主动调用publis_async)
2. **过于依赖事件**：由于发布者和订阅者是通过事件进行通信的，因此如果事件的处理出现问题，可能会影响到整个系统的运行。
3. **一对一模型限制**：由于每个事件只能有一个订阅者，这可能限制了系统的扩展性。如果需要对一个事件进行多种处理，就需要发布多个事件，这可能会导致事件的管理变得复杂。